#!/usr/bin/env ruby

require 'optparse'
require 'theseus'
require 'theseus/formatters/png'

animate = false
output = "maze"
width = height = nil
sparse = 0

png_opts = Theseus::Formatters::PNG::DEFAULTS.dup
maze_opts = { mask: nil,
  randomness: 50, weave: 0, symmetry: :none, braid: 0,
  entrance: nil, exit: nil }

OptionParser.new do |opts|
  opts.on("-B", "--background COLOR", "rgba hex background color for maze (default %08X)" % png_opts[:background]) do |c|
    png_opts[:background] = c
  end

  opts.on("-C", "--cellcolor COLOR", "rgba hex cell color for maze (default %08X)" % png_opts[:cell_color]) do |c|
    png_opts[:cell_color] = c
  end

  opts.on("-L", "--wallcolor COLOR", "rgba hex wall color for maze (default %08X)" % png_opts[:wall_color]) do |c|
    png_opts[:wall_color] = c
  end

  opts.on("-U", "--solutioncolor COLOR", "rgba hex color for the answer path (default %08X)" % png_opts[:solution_color]) do |c|
    png_opts[:solution_color] = c
  end

  opts.on("-c", "--cell N", Integer, "size of each cell (default #{png_opts[:cell_size]})") do |c|
    png_opts[:cell_size] = c
  end

  opts.on("-b", "--border N", Integer, "border padding around outside (default #{png_opts[:outer_padding]})") do |c|
    png_opts[:outer_padding] = c
  end

  opts.on("-p", "--padding N", Integer, "padding around cell (default #{png_opts[:cell_padding]})") do |c|
    png_opts[:cell_padding] = c
  end

  opts.on("-W", "--wall N", Integer, "thickness of walls (default #{png_opts[:wall_width]})") do |c|
    png_opts[:wall_width] = c
  end

  opts.on("-a", "--[no-]animate", "emit frames for each step") do |v|
    animate = v
  end

  opts.on("-o", "--output FILE", "where to save the file(s)") do |f|
    output = f
  end

  opts.on("-m", "--mask [FILE]", "png file to use as mask") do |m|
    maze_opts[:mask] = Theseus::Mask.from_png(m)
  end

  opts.on("-s", "--seed N", Integer, "random seed to use") do |s|
    srand(s)
  end

  opts.on("-y", "--symmetry TYPE", "one of none,x,y,xy,radial (default is '#{maze_opts[:symmetry]}')") do |s|
    maze_opts[:symmetry] = s.to_sym
  end

  opts.on("-w", "--width N", Integer, "width of the maze (default 20, or mask width)") do |w|
    width = w
  end

  opts.on("-H", "--height N", Integer, "height of the maze (default 20 or mask height)") do |h|
    height = h
  end

  opts.on("-e", "--weave N", Integer, "0-100, chance of a passage to go over/under another (default #{maze_opts[:weave]})") do |v|
    maze_opts[:weave] = v
  end

  opts.on("-r", "--random N", Integer, "0-100, randomness of maze (default #{maze_opts[:randomness]})") do |r|
    maze_opts[:randomness] = r
  end

  opts.on("-S", "--sparse N", Integer, "how sparse to make the maze (default #{sparse})") do |s|
    sparse = s
  end

  opts.on("-d", "--braid N", Integer, "0-100, percentage of deadends to remove (default #{maze_opts[:braid]})") do |b|
    maze_opts[:braid] = b
  end

  opts.on("-E", "--enter [X,Y]", "the entrance of the maze (default -1,0)") do |s|
    maze_opts[:entrance] = s.split(/,/).map { |v| v.to_i }
  end

  opts.on("-X", "--exit [X,Y]", "the exit of the maze (default width,height-1)") do |s|
    maze_opts[:exit] = s.split(/,/).map { |v| v.to_i }
  end

  opts.on("-v", "--[no-]solve", "whether to display the solution of the maze") do |s|
    png_opts[:solution] = s
  end

  opts.on("-h", "--help", "this help info") do
    puts opts
    exit
  end
end.parse!

if animate
  abort "sparse cannot be used for animated mazes" if sparse > 0
  abort "cannot specify both solve and animate" if png_opts[:solution]

  png_opts[:background] = ChunkyPNG::Color.from_hex(png_opts[:background]) unless Fixnum === png_opts[:background]

  if png_opts[:background] & 0xFF != 0xFF
    warn "if you intend to make a movie out of the frames from the animation,"
    warn "it is HIGHLY RECOMMENDED that you use a fully opaque background color."
  end
end

maze_opts[:mask] ||= Theseus::TransparentMask.new(width || 20, height || 20)
width ||= maze_opts[:mask].width
height ||= maze_opts[:mask].height
maze = Theseus::Maze.new(width, height, maze_opts)

if animate
  step = 0
  maze.generate! do
    f = "%s-%04d.png" % [output, step]
    step += 1
    File.open(f, "w") { |io| io.write(maze.to(:png, png_opts)) }
    print "."
  end

  f = "%s-%04d.png" % [output, step]
  File.open(f, "w") { |io| io.write(maze.to(:png, png_opts)) }
  puts

  puts "done, %d frames written to %s-*.png" % [step+1, output]
else
  maze.generate!
  sparse.times { maze.sparsify! }
  File.open(output + ".png", "w") { |io| io.write(maze.to(:png, png_opts)) }
  puts "maze written to #{output}.png"
end
